/* DO NOT MODIFY:  This source is generated by the scripts in the
 * vi-firmware repository.
 *
 * Generated for v7.x of the OpenXC VI firmware.
 */

#include "diagnostics.h"
#include "can/canread.h"
#include "can/canwrite.h"
#include "signals.h"
#include "obd2.h"
#include "util/log.h"
#include "config.h"
#include "shared_handlers.h"

namespace can = openxc::can;

using openxc::util::log::debug;
using openxc::pipeline::Pipeline;
using openxc::config::getConfiguration;
using openxc::can::read::booleanDecoder;
using openxc::can::read::stateDecoder;
using openxc::can::read::ignoreDecoder;
using openxc::diagnostics::obd2::handleObd2Pid;
using namespace openxc::signals::handlers;

const int MESSAGE_SET_COUNT = 1;
CanMessageSet MESSAGE_SETS[MESSAGE_SET_COUNT] = {
    { 0, "generic", 1, 4, 8, 0 },
};

const int MAX_CAN_BUS_COUNT = 2;
CanBus CAN_BUSES[][MAX_CAN_BUS_COUNT] = {
    { // message set: generic
        { speed: 500000,
        address: 1,
        maxMessageFrequency: 0,
        rawWritable: false,
        passthroughCanMessages: false,
        bypassFilters: false,
        loopback: false
        },

    },
};

const int MAX_MESSAGE_COUNT = 4;
CanMessageDefinition CAN_MESSAGES[][MAX_MESSAGE_COUNT] = {
    { // message set: generic
        { bus: &CAN_BUSES[0][0], id: 0x201, format: STANDARD, frequencyClock: {0.000000}, forceSendChanged: true}, // Engine_Gen_1
        { bus: &CAN_BUSES[0][0], id: 0x1040, format: EXTENDED, frequencyClock: {0.000000}, forceSendChanged: true}, // bcm_request
        { bus: &CAN_BUSES[0][0], id: 0x1162, format: EXTENDED, frequencyClock: {0.000000}, forceSendChanged: true}, // u2c_stat2
        { bus: &CAN_BUSES[0][0], id: 0x1217, format: EXTENDED, frequencyClock: {0.000000}, forceSendChanged: true}, // Engine_Gen_3
    },
};

const int MAX_SIGNAL_STATES = 12;
const int MAX_SIGNALS_WITH_STATES_COUNT = 0;
const CanSignalState SIGNAL_STATES[][MAX_SIGNALS_WITH_STATES_COUNT][MAX_SIGNAL_STATES] = {
};

const int MAX_SIGNAL_COUNT = 8;
CanSignal SIGNALS[][MAX_SIGNAL_COUNT] = {
    { // message set: generic
        {message: &CAN_MESSAGES[0][0], genericName: "accelerator_pedal_position", bitPosition: 39, bitSize: 8, factor: 1.000000, offset: 0.000000, minValue: 0.000000, maxValue: 0.000000, frequencyClock: {0.000000}, sendSame: true, forceSendChanged: false, states: NULL, stateCount: 0, writable: false, decoder: NULL, encoder: NULL}, // AccActPos
        {message: &CAN_MESSAGES[0][0], genericName: "engine_speed", bitPosition: 15, bitSize: 16, factor: 1.000000, offset: 0.000000, minValue: 0.000000, maxValue: 0.000000, frequencyClock: {0.000000}, sendSame: true, forceSendChanged: false, states: NULL, stateCount: 0, writable: false, decoder: NULL, encoder: NULL}, // EngSpd
        {message: &CAN_MESSAGES[0][1], genericName: "battery_contactor_status", bitPosition: 5, bitSize: 2, factor: 1.000000, offset: 0.000000, minValue: 0.000000, maxValue: 0.000000, frequencyClock: {0.000000}, sendSame: true, forceSendChanged: false, states: NULL, stateCount: 0, writable: false, decoder: NULL, encoder: NULL}, // bcm_mainc_stat
        {message: &CAN_MESSAGES[0][1], genericName: "battery_state_of_charge", bitPosition: 31, bitSize: 8, factor: 1.000000, offset: 0.000000, minValue: 0.000000, maxValue: 0.000000, frequencyClock: {0.000000}, sendSame: true, forceSendChanged: false, states: NULL, stateCount: 0, writable: false, decoder: NULL, encoder: NULL}, // bcm_soc
        {message: &CAN_MESSAGES[0][1], genericName: "battery_voltage", bitPosition: 51, bitSize: 12, factor: 1.000000, offset: 0.000000, minValue: 0.000000, maxValue: 0.000000, frequencyClock: {0.000000}, sendSame: true, forceSendChanged: false, states: NULL, stateCount: 0, writable: false, decoder: NULL, encoder: NULL}, // bcm_vbat
        {message: &CAN_MESSAGES[0][1], genericName: "bcm_ibat", bitPosition: 39, bitSize: 16, factor: 1.000000, offset: 0.000000, minValue: 0.000000, maxValue: 0.000000, frequencyClock: {0.000000}, sendSame: true, forceSendChanged: false, states: NULL, stateCount: 0, writable: false, decoder: NULL, encoder: NULL}, // bcm_ibat
        {message: &CAN_MESSAGES[0][2], genericName: "dcdc_heatplate_thermistor", bitPosition: 32, bitSize: 8, factor: 1.000000, offset: 0.000000, minValue: 0.000000, maxValue: 0.000000, frequencyClock: {0.000000}, sendSame: true, forceSendChanged: false, states: NULL, stateCount: 0, writable: false, decoder: NULL, encoder: NULL}, // dcdc_temp
        {message: &CAN_MESSAGES[0][3], genericName: "engine_coolant_temp", bitPosition: 23, bitSize: 8, factor: 1.000000, offset: 0.000000, minValue: 0.000000, maxValue: 0.000000, frequencyClock: {0.000000}, sendSame: true, forceSendChanged: false, states: NULL, stateCount: 0, writable: false, decoder: NULL, encoder: NULL}, // EngCltTmp
    },
};

void openxc::signals::initialize(openxc::diagnostics::DiagnosticsManager* diagnosticsManager) {
    switch(getConfiguration()->messageSetIndex) {
    case 0: // message set: generic
        break;
    }
}

void openxc::signals::loop() {
    switch(getConfiguration()->messageSetIndex) {
    case 0: // message set: generic
        break;
    }
}

const int MAX_COMMAND_COUNT = 0;
CanCommand COMMANDS[][MAX_COMMAND_COUNT] = {
};

void openxc::signals::decodeCanMessage(Pipeline* pipeline, CanBus* bus, CanMessage* message) {
    switch(getConfiguration()->messageSetIndex) {
    case 0: // message set: generic
        switch(bus->address) {
        case 1:
            switch (message->id) {
            case 0x201: // Engine_Gen_1
                can::read::translateSignal(&SIGNALS[0][0], message, SIGNALS[0], getSignalCount(), pipeline); // AccActPos
                can::read::translateSignal(&SIGNALS[0][1], message, SIGNALS[0], getSignalCount(), pipeline); // EngSpd
                break;
            case 0x1040: // bcm_request
                can::read::translateSignal(&SIGNALS[0][2], message, SIGNALS[0], getSignalCount(), pipeline); // bcm_mainc_stat
                can::read::translateSignal(&SIGNALS[0][3], message, SIGNALS[0], getSignalCount(), pipeline); // bcm_soc
                can::read::translateSignal(&SIGNALS[0][4], message, SIGNALS[0], getSignalCount(), pipeline); // bcm_vbat
                can::read::translateSignal(&SIGNALS[0][5], message, SIGNALS[0], getSignalCount(), pipeline); // bcm_ibat
                break;
            case 0x1162: // u2c_stat2
                can::read::translateSignal(&SIGNALS[0][6], message, SIGNALS[0], getSignalCount(), pipeline); // dcdc_temp
                break;
            case 0x1217: // Engine_Gen_3
                can::read::translateSignal(&SIGNALS[0][7], message, SIGNALS[0], getSignalCount(), pipeline); // EngCltTmp
                break;
            }
            break;
        }
        break;
    }
}


CanCommand* openxc::signals::getCommands() {
    return COMMANDS[getActiveMessageSet()->index];
}

int openxc::signals::getCommandCount() {
    return getActiveMessageSet()->commandCount;
}

CanMessageDefinition* openxc::signals::getMessages() {
    return CAN_MESSAGES[getActiveMessageSet()->index];
}

int openxc::signals::getMessageCount() {
    return getActiveMessageSet()->messageCount;
}

CanSignal* openxc::signals::getSignals() {
    return SIGNALS[getActiveMessageSet()->index];
}

int openxc::signals::getSignalCount() {
    return getActiveMessageSet()->signalCount;
}

CanBus* openxc::signals::getCanBuses() {
    return CAN_BUSES[getActiveMessageSet()->index];
}

int openxc::signals::getCanBusCount() {
    return getActiveMessageSet()->busCount;
}

CanMessageSet* openxc::signals::getActiveMessageSet() {
    return &MESSAGE_SETS[getConfiguration()->messageSetIndex];
}

CanMessageSet* openxc::signals::getMessageSets() {
    return MESSAGE_SETS;
}

int openxc::signals::getMessageSetCount() {
    return MESSAGE_SET_COUNT;
}

